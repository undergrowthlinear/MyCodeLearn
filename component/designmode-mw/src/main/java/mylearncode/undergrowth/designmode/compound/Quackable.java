package mylearncode.undergrowth.designmode.compound;


/**
 * 
 * 复合模式-->在一个解决方案中结合两个或者多个模式，以解决一般或者重复发生的问题 
 * 模式-->是在某种情境下，针对某种问题的某种解决方案 
 * 模式类目完整的描述设计模式
 * 三次规则：当你的模式在真实世界中的三个方案中成功的运用 
 * 
 * OO原则
 * 封装变化
 * 多用组合 少用继承
 * 针对接口编程 而非实现
 * 为交互对象之间的松耦合设计而努力
 * 对扩展开放 对修改关闭
 * 依赖抽象 而不是具体实现
 * 只和你的朋友交谈
 * 好莱坞法则-->别找我 我会找你
 * 类应该只有一个改变的理由
 * 
 * 模式分类
 * 创建型(5个)：单例模式(确保类只有一个对象被创建，并提供一个全局的访问点)、原型模式(当创建给定类的实例的过程很复杂或者很昂贵时
 * )、工厂方法(由子类决定要创建的类是哪一个)、抽象工厂(创建依赖的对象家族
 * ，而又无需指定具体的类)、生成器模式(封装一个产品的构造过程，并允许按步骤构造)
 * SBPFF
 * 结构型(7个):装饰模式(包装一个对象，以提供更多的行为)、代理模式(包装对象，以提供对这个对象的访问
 * )、组合模式(用一致的方式处理对象集合和单个对象)、
 * 外观模式(简化一群类的接口)、适配器模式(封装对象，提供不同的接口)、蝇量模式(一个实例提供许多虚拟实例)、桥接模式(独立改变实现和抽象)
 * DPCFAFB----ABCDPFF
 * 行为型(11个):策略模式(将可变的行为封装起来
 * ，使用委托决定使用哪一个)、状态模式(封装了可变的状态，使用委托在行为间切换)、模板方法(由子类决定实现算法中的某个步骤
 * )、迭代器模式(在集合之间迭代，而又无需暴露集合的实现
 * )、命令模式(封装请求为对象)、观察者模式(让对象能够在状态改变时被通知)、责任链模式(为某个请求创建对象链
 * )、解释器模式(为语言创建解释器)、中介者模式(控制对象之间复杂的沟通)、备忘录模式(返回对象之前的状态)、访问者模式(为组合增加新的行为)
 * SSMICOCIMMV--IICCSSMMMVO
 * 反模式：告诉你如何采用一个不好的解决方案解决一个问题
 * 
 * 复合模式示例： 鸭子模拟器 由抽象工厂模式创建鸭子 由装饰模式为鸭子添加附加行为 由组合模式管理鸭子组合 由迭代模式遍历鸭子和鸭子组合 由观察者模式观察鸭子的行为
 * 由适配器模式将鹅转变为鸭子
 * 
 * @author Administrator
 * 
 */

public interface Quackable extends QuackObservable {
	public void quack();
}

